From afc84763e0cc7d405c4e869695f5b853ba9b7332 Mon Sep 17 00:00:00 2001
From: David King <dking@redhat.com>
Date: Thu, 5 Apr 2018 10:11:54 +0100
Subject: [PATCH] Add dbus-run-session

Based on f691c24dd1bff1c6cd38fe3b5f2f2831e175464c by Simon McVittie.
Adapted for dbus-1.2 branch.
---
 tools/Makefile.am        |   7 +-
 tools/dbus-run-session.1 | 100 ++++++++++
 tools/dbus-run-session.c | 477 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 582 insertions(+), 2 deletions(-)
 create mode 100644 tools/dbus-run-session.1
 create mode 100644 tools/dbus-run-session.c

diff --git a/tools/Makefile.am b/tools/Makefile.am
index 9fad7a78..e7db0882 100644
--- a/tools/Makefile.am
+++ b/tools/Makefile.am
@@ -2,7 +2,7 @@ configdir=$(sysconfdir)/dbus-1
 
 INCLUDES=-I$(top_srcdir) $(DBUS_CLIENT_CFLAGS) $(DBUS_X_CFLAGS) -DDBUS_LOCALEDIR=\"@EXPANDED_DATADIR@/locale\" -DDBUS_COMPILATION -DDBUS_DAEMONDIR=\"@DBUS_DAEMONDIR@\" -DDBUS_MACHINE_UUID_FILE=\""$(localstatedir)/lib/dbus/machine-id"\"
 
-bin_PROGRAMS=dbus-send dbus-monitor dbus-launch dbus-cleanup-sockets dbus-uuidgen
+bin_PROGRAMS=dbus-send dbus-monitor dbus-launch dbus-cleanup-sockets dbus-uuidgen dbus-run-session
 
 dbus_send_SOURCES=				\
 	dbus-print-message.c			\
@@ -19,6 +19,9 @@ dbus_launch_SOURCES=				\
 	dbus-launch-x11.c			\
 	dbus-launch.h
 
+dbus_run_session_SOURCES =			\
+	dbus-run-session.c
+
 dbus_cleanup_sockets_SOURCES=			\
 	dbus-cleanup-sockets.c
 
@@ -37,7 +40,7 @@ dbus_uuidgen_LDFLAGS=@R_DYNAMIC_LDFLAG@
 dbus_launch_LDADD= $(DBUS_X_LIBS) $(DBUS_CLIENT_LIBS)
 dbus_launch_LDFLAGS=@R_DYNAMIC_LDFLAG@
 
-man_MANS = dbus-send.1 dbus-monitor.1 dbus-launch.1 dbus-cleanup-sockets.1 dbus-uuidgen.1
+man_MANS = dbus-send.1 dbus-monitor.1 dbus-launch.1 dbus-cleanup-sockets.1 dbus-uuidgen.1 dbus-run-session.1
 EXTRA_DIST = $(man_MANS) run-with-tmp-session-bus.sh
 CLEANFILES = 				\
 	run-with-tmp-session-bus.conf
diff --git a/tools/dbus-run-session.1 b/tools/dbus-run-session.1
new file mode 100644
index 00000000..8b270ebe
--- /dev/null
+++ b/tools/dbus-run-session.1
@@ -0,0 +1,100 @@
+.TH dbus\-run\-session 1
+.SH NAME
+dbus\-run\-session \- start a process as a new D-Bus session
+.SH SYNOPSIS
+.B dbus\-run\-session
+.RB [ \-\-config\-file
+.IR FILENAME ]
+.RB [ \-\-dbus\-daemon
+.IR BINARY ]
+.RB [ \-\- ]
+.IR PROGRAM " [" ARGUMENTS ...]
+.P
+.B dbus\-run\-session \-\-help
+.P
+.B dbus\-run\-session \-\-version
+.SH DESCRIPTION
+.B dbus\-run\-session
+is used to start a session bus instance of
+.B dbus\-daemon
+from a shell script, and start a specified program in that session. The
+.B dbus\-daemon
+will run for as long as the program does, after which it will terminate.
+.P
+One use is to run a shell with its own
+.B dbus\-daemon
+in a text\(hymode or SSH session, and have the
+.B dbus\-daemon
+terminate automatically on leaving the sub\(hyshell, like this:
+.P
+    dbus\-run\-session \-\- bash
+.P
+or to replace the login shell altogether, by combining \fBdbus\-run\-session\fR
+with the \fBexec\fR builtin:
+.P
+    exec dbus\-run\-session \-\- bash
+.P
+Another use is to run regression tests and similar things in an isolated
+D-Bus session, to avoid either interfering with the "real" D-Bus session
+or relying on there already being a D-Bus session active, for instance:
+.P
+    dbus\-run\-session \-\- make check
+.P
+or (in
+.BR automake (1)):
+.P
+.nf
+    TESTS_ENVIRONMENT = MY_DEBUG=all dbus\-run\-session \-\-
+.fi
+.P
+.SH OPTIONS
+.TP
+\fB\-\-config\-file=\fIFILENAME\fR, \fB\-\-config\-file\fR \fIFILENAME\fR
+Pass
+.BI \-\-config-file= FILENAME
+to the bus daemon, instead of passing it the
+.B \-\-session
+argument. See
+.BR dbus-daemon (1).
+.TP
+\fB\-\-dbus\-daemon=\fIBINARY\fR, \fB\-\-dbus\-daemon\fR \fIBINARY\fR
+Run \fIBINARY\fR as \fBdbus\-daemon\fR(1), instead of searching the \fBPATH\fR
+in the usual way for an executable called \fBdbus\-daemon\fR.
+.TP
+.B \-\-help
+Print usage information and exit.
+.TP
+.B \-\-version
+Print the version of dbus\-run\-session and exit.
+.SH EXIT STATUS
+.B dbus\-run\-session
+exits with the exit status of
+.IR PROGRAM ,
+0 if the
+.BR \-\-help " or " \-\-version
+options were used, 127 on an error within
+.B dbus\-run\-session
+itself, or
+.RI 128+ n
+if the
+.I PROGRAM
+was killed by signal
+.IR n .
+.SH ENVIRONMENT
+.B PATH
+is searched to find
+.IR PROGRAM ,
+and (if the \-\-dbus\-daemon option is not used or its argument does not
+contain a
+.BR / " character) to find " dbus\-daemon .
+.P
+The session bus' address is made available to
+.I PROGRAM
+in the environment variable
+.BR DBUS_SESSION_BUS_ADDRESS .
+.SH BUGS
+Please send bug reports to the D\-Bus mailing list or bug tracker,
+see http://www.freedesktop.org/software/dbus/
+.SH SEE ALSO
+.BR dbus\-daemon (1),
+.BR dbus\-launch (1)
diff --git a/tools/dbus-run-session.c b/tools/dbus-run-session.c
new file mode 100644
index 00000000..4f0b32b5
--- /dev/null
+++ b/tools/dbus-run-session.c
@@ -0,0 +1,477 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* dbus-run-session.c - run a child process in its own session
+ *
+ * Copyright © 2003-2006 Red Hat, Inc.
+ * Copyright © 2006 Thiago Macieira <thiago@kde.org>
+ * Copyright © 2011-2012 Nokia Corporation
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <config.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#define MAX_ADDR_LEN 512
+#define PIPE_READ_END  0
+#define PIPE_WRITE_END 1
+
+/* PROCESSES
+ *
+ * If you are in a shell and run "dbus-run-session myapp", here is what
+ * happens (compare and contrast with dbus-launch):
+ *
+ * shell
+ *   \- dbus-run-session myapp
+ *      \- dbus-daemon --nofork --print-address --session
+ *      \- myapp
+ *
+ * All processes are long-running.
+ *
+ * When myapp exits, dbus-run-session kills dbus-daemon and terminates.
+ *
+ * If dbus-daemon exits, dbus-run-session warns and continues to run.
+ *
+ * PIPES
+ *
+ * dbus-daemon --print-address -> bus_address_pipe -> d-r-s
+ */
+
+static const char me[] = "dbus-run-session";
+
+static void
+usage (int ecode)
+{
+  fprintf (stderr,
+      "%s [OPTIONS] [--] PROGRAM [ARGUMENTS]\n"
+      "%s --version\n"
+      "%s --help\n"
+      "\n"
+      "Options:\n"
+      "--dbus-daemon=BINARY       run BINARY instead of dbus-daemon\n"
+      "--config-file=FILENAME     pass to dbus-daemon instead of --session\n"
+      "\n",
+      me, me, me);
+  exit (ecode);
+}
+
+static void
+version (void)
+{
+  printf ("%s %s\n"
+          "Copyright (C) 2003-2006 Red Hat, Inc.\n"
+          "Copyright (C) 2006 Thiago Macieira\n"
+          "Copyright © 2011-2012 Nokia Corporation\n"
+          "\n"
+          "This is free software; see the source for copying conditions.\n"
+          "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
+          me, VERSION);
+  exit (0);
+}
+
+static void
+oom (void)
+{
+  fprintf (stderr, "%s: out of memory\n", me);
+  exit (1);
+}
+
+static void *
+xmalloc (size_t bytes)
+{
+  void *ret;
+
+  if (bytes == 0)
+    bytes = 1;
+
+  ret = malloc (bytes);
+
+  if (ret == NULL)
+    oom ();
+
+  return ret;
+}
+
+typedef enum
+{
+  READ_STATUS_OK,    /**< Read succeeded */
+  READ_STATUS_ERROR, /**< Some kind of error */
+  READ_STATUS_EOF    /**< EOF returned */
+} ReadStatus;
+
+static ReadStatus
+read_line (int        fd,
+           char      *buf,
+           size_t     maxlen)
+{
+  size_t bytes = 0;
+  ReadStatus retval;
+
+  memset (buf, '\0', maxlen);
+  maxlen -= 1; /* ensure nul term */
+
+  retval = READ_STATUS_OK;
+
+  while (1)
+    {
+      ssize_t chunk;
+      size_t to_read;
+
+    again:
+      to_read = maxlen - bytes;
+
+      if (to_read == 0)
+        break;
+
+      chunk = read (fd,
+                    buf + bytes,
+                    to_read);
+      if (chunk < 0 && errno == EINTR)
+        goto again;
+
+      if (chunk < 0)
+        {
+          retval = READ_STATUS_ERROR;
+          break;
+        }
+      else if (chunk == 0)
+        {
+          retval = READ_STATUS_EOF;
+          break; /* EOF */
+        }
+      else /* chunk > 0 */
+        bytes += chunk;
+    }
+
+  if (retval == READ_STATUS_EOF &&
+      bytes > 0)
+    retval = READ_STATUS_OK;
+
+  /* whack newline */
+  if (retval != READ_STATUS_ERROR &&
+      bytes > 0 &&
+      buf[bytes-1] == '\n')
+    buf[bytes-1] = '\0';
+
+  return retval;
+}
+
+static void
+exec_dbus_daemon (const char *dbus_daemon,
+                  int         bus_address_pipe[2],
+                  const char *config_file)
+{
+  /* Child process, which execs dbus-daemon or dies trying */
+#define MAX_FD_LEN 64
+  char write_address_fd_as_string[MAX_FD_LEN];
+
+  close (bus_address_pipe[PIPE_READ_END]);
+
+  sprintf (write_address_fd_as_string, "%d", bus_address_pipe[PIPE_WRITE_END]);
+
+  execlp (dbus_daemon,
+          dbus_daemon,
+          "--nofork",
+          "--print-address", write_address_fd_as_string,
+          config_file ? "--config-file" : "--session",
+          config_file, /* has to be last in this varargs list */
+          NULL);
+
+  fprintf (stderr, "%s: failed to execute message bus daemon '%s': %s\n",
+           me, dbus_daemon, strerror (errno));
+}
+
+static void
+exec_app (int prog_arg, char **argv)
+{
+  execvp (argv[prog_arg], argv + prog_arg);
+
+  fprintf (stderr, "%s: failed to exec '%s': %s\n", me, argv[prog_arg],
+           strerror (errno));
+  exit (1);
+}
+
+int
+main (int argc, char **argv)
+{
+  int prog_arg = 0;
+  int bus_address_pipe[2] = { 0, 0 };
+  const char *config_file = NULL;
+  const char *dbus_daemon = NULL;
+  char bus_address[MAX_ADDR_LEN] = { 0 };
+  const char *prev_arg = NULL;
+  int i = 1;
+  int requires_arg = 0;
+  pid_t bus_pid;
+  pid_t app_pid;
+  char *envvar;
+
+  while (i < argc)
+    {
+      const char *arg = argv[i];
+
+      if (requires_arg)
+        {
+          const char **arg_dest;
+
+          assert (prev_arg != NULL);
+
+          if (strcmp (prev_arg, "--config-file") == 0)
+            {
+              arg_dest = &config_file;
+            }
+          else if (strcmp (prev_arg, "--dbus-daemon") == 0)
+            {
+              arg_dest = &dbus_daemon;
+            }
+          else
+            {
+              /* shouldn't happen */
+              fprintf (stderr, "%s: internal error: %s not fully implemented\n",
+                       me, prev_arg);
+              return 127;
+            }
+
+          if (*arg_dest != NULL)
+            {
+              fprintf (stderr, "%s: %s given twice\n", me, prev_arg);
+              return 127;
+            }
+
+          *arg_dest = arg;
+          requires_arg = 0;
+          prev_arg = arg;
+          ++i;
+          continue;
+        }
+
+      if (strcmp (arg, "--help") == 0 ||
+          strcmp (arg, "-h") == 0 ||
+          strcmp (arg, "-?") == 0)
+        {
+          usage (0);
+        }
+      else if (strcmp (arg, "--version") == 0)
+        {
+          version ();
+        }
+      else if (strstr (arg, "--config-file=") == arg)
+        {
+          const char *file;
+
+          if (config_file != NULL)
+            {
+              fprintf (stderr, "%s: --config-file given twice\n", me);
+              return 127;
+            }
+
+          file = strchr (arg, '=');
+          ++file;
+
+          config_file = file;
+        }
+      else if (strstr (arg, "--dbus-daemon=") == arg)
+        {
+          const char *file;
+
+          if (dbus_daemon != NULL)
+            {
+              fprintf (stderr, "%s: --dbus-daemon given twice\n", me);
+              return 127;
+            }
+
+          file = strchr (arg, '=');
+          ++file;
+
+          dbus_daemon = file;
+        }
+      else if (strcmp (arg, "--config-file") == 0 ||
+               strcmp (arg, "--dbus-daemon") == 0)
+        {
+          requires_arg = 1;
+        }
+      else if (arg[0] == '-')
+        {
+          if (strcmp (arg, "--") != 0)
+            {
+              fprintf (stderr, "%s: option '%s' is unknown\n", me, arg);
+              return 127;
+            }
+          else
+            {
+              prog_arg = i + 1;
+              break;
+            }
+        }
+      else
+        {
+          prog_arg = i;
+          break;
+        }
+
+      prev_arg = arg;
+      ++i;
+    }
+
+  /* "dbus-run-session" and "dbus-run-session ... --" are not allowed:
+   * there must be something to run */
+  if (prog_arg < 1 || prog_arg >= argc)
+    {
+      fprintf (stderr, "%s: a non-option argument is required\n", me);
+      return 127;
+    }
+
+  if (requires_arg)
+    {
+      fprintf (stderr, "%s: option '%s' requires an argument\n", me, prev_arg);
+      return 127;
+    }
+
+  if (dbus_daemon == NULL)
+    dbus_daemon = "dbus-daemon";
+
+  if (pipe (bus_address_pipe) < 0)
+    {
+      fprintf (stderr, "%s: failed to create pipe: %s\n", me, strerror (errno));
+      return 127;
+    }
+
+  bus_pid = fork ();
+
+  if (bus_pid < 0)
+    {
+      fprintf (stderr, "%s: failed to fork: %s\n", me, strerror (errno));
+      return 127;
+    }
+
+  if (bus_pid == 0)
+    {
+      /* child */
+      exec_dbus_daemon (dbus_daemon, bus_address_pipe, config_file);
+      /* not reached */
+      return 127;
+    }
+
+  close (bus_address_pipe[PIPE_WRITE_END]);
+
+  switch (read_line (bus_address_pipe[PIPE_READ_END], bus_address, MAX_ADDR_LEN))
+    {
+    case READ_STATUS_OK:
+      break;
+
+    case READ_STATUS_EOF:
+      fprintf (stderr, "%s: EOF reading address from bus daemon\n", me);
+      return 127;
+      break;
+
+    case READ_STATUS_ERROR:
+      fprintf (stderr, "%s: error reading address from bus daemon: %s\n",
+               me, strerror (errno));
+      return 127;
+      break;
+    }
+
+  close (bus_address_pipe[PIPE_READ_END]);
+
+  envvar = xmalloc (strlen ("DBUS_SESSION_BUS_ADDRESS=") +
+                    strlen (bus_address) + 1);
+  strcpy (envvar, "DBUS_SESSION_BUS_ADDRESS=");
+  strcat (envvar, bus_address);
+  putenv (envvar);
+
+  app_pid = fork ();
+
+  if (app_pid < 0)
+    {
+      fprintf (stderr, "%s: failed to fork: %s\n", me, strerror (errno));
+      return 127;
+    }
+
+  if (app_pid == 0)
+    {
+      /* child */
+      exec_app (prog_arg, argv);
+      /* not reached */
+      return 127;
+    }
+
+  while (1)
+    {
+      int child_status;
+      pid_t child_pid = waitpid (-1, &child_status, 0);
+
+      if (child_pid == (pid_t) -1)
+        {
+          int errsv = errno;
+
+          if (errsv == EINTR)
+            continue;
+
+          /* shouldn't happen: the only other documented errors are ECHILD,
+           * which shouldn't happen because we terminate when all our children
+           * have died, and EINVAL, which would indicate programming error */
+          fprintf (stderr, "%s: waitpid() failed: %s\n", me, strerror (errsv));
+          return 127;
+        }
+      else if (child_pid == bus_pid)
+        {
+          /* no need to kill it, now */
+          bus_pid = 0;
+
+          if (WIFEXITED (child_status))
+            fprintf (stderr, "%s: dbus-daemon exited with code %d\n",
+                me, WEXITSTATUS (child_status));
+          else if (WIFSIGNALED (child_status))
+            fprintf (stderr, "%s: dbus-daemon terminated by signal %d\n",
+                me, WTERMSIG (child_status));
+          else
+            fprintf (stderr, "%s: dbus-daemon died or something\n", me);
+        }
+      else if (child_pid == app_pid)
+        {
+          if (bus_pid != 0)
+            kill (bus_pid, SIGTERM);
+
+          if (WIFEXITED (child_status))
+            return WEXITSTATUS (child_status);
+
+          /* if it died from a signal, behave like sh(1) */
+          if (WIFSIGNALED (child_status))
+            return 128 + WTERMSIG (child_status);
+
+          /* I give up (this should never be reached) */
+          fprintf (stderr, "%s: child process died or something\n", me);
+          return 127;
+        }
+      else
+        {
+          fprintf (stderr, "%s: ignoring unknown child process %ld\n", me,
+              (long) child_pid);
+        }
+    }
+
+  return 0;
+}
-- 
2.16.2

commit b3800b7a666fcefc37eeb25a030241d5809a7246
Author: Colin Walters <walters@verbum.org>
Date:   Fri Sep 28 12:01:56 2012 -0400

    hardening: Remove activation helper handling for DBUS_VERBOSE
    
    It's not really useful.
    
    See https://bugs.freedesktop.org/show_bug.cgi?id=52202#c17
    
    Conflicts:
            bus/activation-helper.c

diff --git a/bus/activation-helper.c b/bus/activation-helper.c
index baba8f04..bc5ed07b 100644
--- a/bus/activation-helper.c
+++ b/bus/activation-helper.c
@@ -140,18 +140,12 @@ out_all:
   return desktop_file;
 }
 
-/* Cleares the environment, except for DBUS_VERBOSE and DBUS_STARTER_x */
+/* Clears the environment, except for DBUS_STARTER_x */
 static dbus_bool_t
 clear_environment (DBusError *error)
 {
-  const char *debug_env = NULL;
   const char *starter_env = NULL;
 
-#ifdef DBUS_ENABLE_VERBOSE_MODE
-  /* are we debugging */
-  debug_env = _dbus_getenv ("DBUS_VERBOSE");
-#endif
-
   /* we save the starter */
   starter_env = _dbus_getenv ("DBUS_STARTER_ADDRESS");
 
@@ -165,12 +159,6 @@ clear_environment (DBusError *error)
     }
 #endif
 
-#ifdef DBUS_ENABLE_VERBOSE_MODE
-  /* restore the debugging environment setting if set */
-  if (debug_env)
-    _dbus_setenv ("DBUS_VERBOSE", debug_env);
-#endif
-
   /* restore the starter */
   if (starter_env)
     _dbus_setenv ("DBUS_STARTER_ADDRESS", starter_env);
commit c5c747dd7613d777a05ddb663409eeea4e61ec74
Author: Geoffrey Thomas <gthomas@mokafive.com>
Date:   Thu Sep 27 22:02:06 2012 -0700

    activation-helper: Ensure DBUS_STARTER_ADDRESS is set correctly
    
    The fix for CVE-2012-3524 filters out all environment variables if
    libdbus is used from a setuid program, to prevent various spoofing
    attacks.
    
    Unfortunately, the activation helper is a setuid program linking
    libdbus, and this creates a regression for launched programs using
    DBUS_STARTER_ADDRESS, since it will no longer exist.
    
    Fix this by hardcoding the starter address to the default system bus
    address.
    
    Signed-off-by: Geoffrey Thomas <gthomas@mokafive.com>
    Signed-off-by: Colin Walters <walters@verbum.org>

diff --git a/bus/activation-helper.c b/bus/activation-helper.c
index bc5ed07b..bfe832ea 100644
--- a/bus/activation-helper.c
+++ b/bus/activation-helper.c
@@ -140,15 +140,12 @@ out_all:
   return desktop_file;
 }
 
-/* Clears the environment, except for DBUS_STARTER_x */
+/* Clears the environment, except for DBUS_STARTER_x,
+ * which we hardcode to the system bus.
+ */
 static dbus_bool_t
 clear_environment (DBusError *error)
 {
-  const char *starter_env = NULL;
-
-  /* we save the starter */
-  starter_env = _dbus_getenv ("DBUS_STARTER_ADDRESS");
-
 #ifndef ACTIVATION_LAUNCHER_TEST
   /* totally clear the environment */
   if (!_dbus_clearenv ())
@@ -159,11 +156,8 @@ clear_environment (DBusError *error)
     }
 #endif
 
-  /* restore the starter */
-  if (starter_env)
-    _dbus_setenv ("DBUS_STARTER_ADDRESS", starter_env);
-
-  /* set the type, which must be system if we got this far */
+  /* Ensure the bus is set to system */
+  _dbus_setenv ("DBUS_STARTER_ADDRESS", DBUS_SYSTEM_BUS_DEFAULT_ADDRESS);
   _dbus_setenv ("DBUS_STARTER_BUS_TYPE", "system");
 
   return TRUE;
commit 87db372c2f9e3c8401f0c8e6e3d20106d168e9a2
Author: Simon McVittie <simon.mcvittie@collabora.co.uk>
Date:   Tue Oct 2 09:34:48 2012 +0100

    activation helper: when compiled for tests, do not reset system bus address
    
    Otherwise, the tests try to connect to the real system bus, which will
    often fail - particularly if you run the tests configured for the default
    /usr/local (with no intention of installing the result), in which case
    the tests would try to connect to /usr/local/var/run/dbus/system_bus_socket.
    
    Reviewed-by: Colin Walters <walters@verbum.org>
    Bug: https://bugs.freedesktop.org/show_bug.cgi?id=52202

diff --git a/bus/activation-helper.c b/bus/activation-helper.c
index bfe832ea..65676574 100644
--- a/bus/activation-helper.c
+++ b/bus/activation-helper.c
@@ -154,11 +154,11 @@ clear_environment (DBusError *error)
                       "could not clear environment\n");
       return FALSE;
     }
-#endif
 
   /* Ensure the bus is set to system */
   _dbus_setenv ("DBUS_STARTER_ADDRESS", DBUS_SYSTEM_BUS_DEFAULT_ADDRESS);
   _dbus_setenv ("DBUS_STARTER_BUS_TYPE", "system");
+#endif
 
   return TRUE;
 }
From 79f8eee8fbe75aeccf48873c26bcb8f38a4b5de8 Mon Sep 17 00:00:00 2001
From: Simon McVittie <simon.mcvittie@collabora.co.uk>
Date: Wed, 5 Jun 2013 19:58:22 +0100
Subject: [PATCH 1/4] Export dbus_setenv() as a utility function

It's sufficiently portable that GLib has an equivalent, and I really
don't want to have to either open-code it in dbus-run-session or
link dbus-run-session statically. We have enough statically-linked
rubbish already.

Bug: https://bugs.freedesktop.org/show_bug.cgi?id=39196
Reviewed-by: Colin Walters <walters@verbum.org>
---
 bus/activation-helper.c  |  5 +++--
 bus/config-parser.c      | 10 ++++++----
 bus/dispatch.c           |  5 +++--
 bus/test-launch-helper.c |  5 +++--
 dbus/dbus-bus.c          |  5 +++--
 dbus/dbus-misc.h         |  3 +++
 dbus/dbus-sysdeps.c      | 14 ++++++++++----
 dbus/dbus-sysdeps.h      |  2 --
 8 files changed, 31 insertions(+), 18 deletions(-)

diff --git a/bus/activation-helper.c b/bus/activation-helper.c
index 65676574..20252bf0 100644
--- a/bus/activation-helper.c
+++ b/bus/activation-helper.c
@@ -40,6 +40,7 @@
 #include <pwd.h>
 #include <grp.h>
 
+#include <dbus/dbus-misc.h>
 #include <dbus/dbus-shell.h>
 #include <dbus/dbus-marshal-validate.h>
 
@@ -156,8 +157,8 @@ clear_environment (DBusError *error)
     }
 
   /* Ensure the bus is set to system */
-  _dbus_setenv ("DBUS_STARTER_ADDRESS", DBUS_SYSTEM_BUS_DEFAULT_ADDRESS);
-  _dbus_setenv ("DBUS_STARTER_BUS_TYPE", "system");
+  dbus_setenv ("DBUS_STARTER_ADDRESS", DBUS_SYSTEM_BUS_DEFAULT_ADDRESS);
+  dbus_setenv ("DBUS_STARTER_BUS_TYPE", "system");
 #endif
 
   return TRUE;
diff --git a/bus/config-parser.c b/bus/config-parser.c
index 5218910b..6f02749e 100644
--- a/bus/config-parser.c
+++ b/bus/config-parser.c
@@ -28,6 +28,8 @@
 #include "selinux.h"
 #include <dbus/dbus-list.h>
 #include <dbus/dbus-internals.h>
+#include <dbus/dbus-misc.h>
+#include <dbus/dbus-sysdeps.h>
 #include <string.h>
 
 typedef enum
@@ -3257,10 +3259,10 @@ test_default_session_servicedirs (void)
     }
 
 #ifdef DBUS_UNIX
-  if (!_dbus_setenv ("XDG_DATA_HOME", "/testhome/foo/.testlocal/testshare"))
+  if (!dbus_setenv ("XDG_DATA_HOME", "/testhome/foo/.testlocal/testshare"))
     _dbus_assert_not_reached ("couldn't setenv XDG_DATA_HOME");
 
-  if (!_dbus_setenv ("XDG_DATA_DIRS", ":/testusr/testlocal/testshare: :/testusr/testshare:"))
+  if (!dbus_setenv ("XDG_DATA_DIRS", ":/testusr/testlocal/testshare: :/testusr/testshare:"))
     _dbus_assert_not_reached ("couldn't setenv XDG_DATA_DIRS");
 #endif
   if (!_dbus_get_standard_session_servicedirs (&dirs))
@@ -3380,10 +3382,10 @@ test_default_system_servicedirs (void)
     }
 
 #ifdef DBUS_UNIX
-  if (!_dbus_setenv ("XDG_DATA_HOME", "/testhome/foo/.testlocal/testshare"))
+  if (!dbus_setenv ("XDG_DATA_HOME", "/testhome/foo/.testlocal/testshare"))
     _dbus_assert_not_reached ("couldn't setenv XDG_DATA_HOME");
 
-  if (!_dbus_setenv ("XDG_DATA_DIRS", ":/testusr/testlocal/testshare: :/testusr/testshare:"))
+  if (!dbus_setenv ("XDG_DATA_DIRS", ":/testusr/testlocal/testshare: :/testusr/testshare:"))
     _dbus_assert_not_reached ("couldn't setenv XDG_DATA_DIRS");
 #endif
   if (!_dbus_get_standard_system_servicedirs (&dirs))
diff --git a/bus/dispatch.c b/bus/dispatch.c
index ca55177b..97b38276 100644
--- a/bus/dispatch.c
+++ b/bus/dispatch.c
@@ -33,6 +33,7 @@
 #include "signals.h"
 #include "test.h"
 #include <dbus/dbus-internals.h>
+#include <dbus/dbus-misc.h>
 #include <string.h>
 
 static dbus_bool_t
@@ -4439,8 +4440,8 @@ setenv_TEST_LAUNCH_HELPER_CONFIG(const DBusString *test_data_dir,
 
   _dbus_verbose ("Setting TEST_LAUNCH_HELPER_CONFIG to '%s'\n", 
                  _dbus_string_get_const_data (&full));
-  
-  _dbus_setenv ("TEST_LAUNCH_HELPER_CONFIG", _dbus_string_get_const_data (&full));
+
+  dbus_setenv ("TEST_LAUNCH_HELPER_CONFIG", _dbus_string_get_const_data (&full));
 
   _dbus_string_free (&full);
 
diff --git a/bus/test-launch-helper.c b/bus/test-launch-helper.c
index d78ca519..3f030643 100644
--- a/bus/test-launch-helper.c
+++ b/bus/test-launch-helper.c
@@ -27,6 +27,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <dbus/dbus-internals.h>
+#include <dbus/dbus-misc.h>
 
 #ifdef DBUS_BUILD_TESTS
 static void
@@ -121,8 +122,8 @@ main (int argc, char **argv)
     return 1;
 
   /* use a config file that will actually work... */
-  _dbus_setenv ("TEST_LAUNCH_HELPER_CONFIG",
-                _dbus_string_get_const_data (&config_file));
+  dbus_setenv ("TEST_LAUNCH_HELPER_CONFIG",
+               _dbus_string_get_const_data (&config_file));
 
   _dbus_string_free (&config_file);
 
diff --git a/dbus/dbus-bus.c b/dbus/dbus-bus.c
index 92ec20ed..abec8587 100644
--- a/dbus/dbus-bus.c
+++ b/dbus/dbus-bus.c
@@ -28,6 +28,7 @@
 #include "dbus-internals.h"
 #include "dbus-message.h"
 #include "dbus-marshal-validate.h"
+#include "dbus-misc.h"
 #include "dbus-threads-internal.h"
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
@@ -306,10 +307,10 @@ init_connections_unlocked (void)
        * the above code will work right
        */
       
-      if (!_dbus_setenv ("DBUS_ACTIVATION_ADDRESS", NULL))
+      if (!dbus_setenv ("DBUS_ACTIVATION_ADDRESS", NULL))
         return FALSE;
 
-      if (!_dbus_setenv ("DBUS_ACTIVATION_BUS_TYPE", NULL))
+      if (!dbus_setenv ("DBUS_ACTIVATION_BUS_TYPE", NULL))
         return FALSE;
       
       if (!_dbus_register_shutdown_func (addresses_shutdown_func,
diff --git a/dbus/dbus-misc.h b/dbus/dbus-misc.h
index f8cb12ff..730651a4 100644
--- a/dbus/dbus-misc.h
+++ b/dbus/dbus-misc.h
@@ -43,6 +43,9 @@ void        dbus_get_version           (int *major_version_p,
                                         int *minor_version_p,
                                         int *micro_version_p);
 
+dbus_bool_t dbus_setenv                (const char *variable,
+                                        const char *value);
+
 /** @} */
 
 DBUS_END_DECLS
diff --git a/dbus/dbus-sysdeps.c b/dbus/dbus-sysdeps.c
index c3acc178..45195a05 100644
--- a/dbus/dbus-sysdeps.c
+++ b/dbus/dbus-sysdeps.c
@@ -28,6 +28,7 @@
 #include "dbus-protocol.h"
 #include "dbus-string.h"
 #include "dbus-list.h"
+#include "dbus-misc.h"
 
 /* NOTE: If you include any unix/windows-specific headers here, you are probably doing something
  * wrong and should be putting some code in dbus-sysdeps-unix.c or dbus-sysdeps-win.c.
@@ -90,6 +91,8 @@ _dbus_abort (void)
 }
 
 /**
+ * @ingroup DBusMisc
+ *
  * Wrapper for setenv(). If the value is #NULL, unsets
  * the environment variable.
  *
@@ -98,13 +101,16 @@ _dbus_abort (void)
  * we can not rely on internal implementation details of
  * the underlying libc library.
  *
+ * This function is not thread-safe, because altering the environment
+ * in Unix is not thread-safe in general.
+ *
  * @param varname name of environment variable
- * @param value value of environment variable
- * @returns #TRUE on success.
+ * @param value value of environment variable, or #NULL to unset
+ * @returns #TRUE on success, #FALSE if not enough memory.
  */
 dbus_bool_t
-_dbus_setenv (const char *varname,
-              const char *value)
+dbus_setenv (const char *varname,
+             const char *value)
 {
   _dbus_assert (varname != NULL);
   
diff --git a/dbus/dbus-sysdeps.h b/dbus/dbus-sysdeps.h
index 3c374d23..2e1893f3 100644
--- a/dbus/dbus-sysdeps.h
+++ b/dbus/dbus-sysdeps.h
@@ -99,8 +99,6 @@ void _dbus_abort (void) _DBUS_GNUC_NORETURN;
 
 dbus_bool_t _dbus_check_setuid (void);
 const char* _dbus_getenv (const char *varname);
-dbus_bool_t _dbus_setenv (const char *varname,
-			  const char *value);
 dbus_bool_t _dbus_clearenv (void);
 char **     _dbus_get_environment (void);
 
-- 
2.16.2


From f0d35f6d28c7c7af21ba3abbf02c98649b40f5ac Mon Sep 17 00:00:00 2001
From: David King <dking@redhat.com>
Date: Thu, 5 Apr 2018 12:28:27 +0100
Subject: [PATCH 2/4] dbus-run-session: remove various extra variables from the
 environment

Adapted from 5ee72fe2e1e8fbb7ae09174e8df3ca28228ddd9b by Simon McVittie.
---
 tools/Makefile.am        |  4 ++++
 tools/dbus-run-session.1 |  8 ++++++++
 tools/dbus-run-session.c | 30 ++++++++----------------------
 3 files changed, 20 insertions(+), 22 deletions(-)

diff --git a/tools/Makefile.am b/tools/Makefile.am
index e7db0882..009a0b1c 100644
--- a/tools/Makefile.am
+++ b/tools/Makefile.am
@@ -22,6 +22,10 @@ dbus_launch_SOURCES=				\
 dbus_run_session_SOURCES =			\
 	dbus-run-session.c
 
+dbus_run_session_LDADD = \
+	$(top_builddir)/dbus/libdbus-1.la \
+	$(NULL)
+
 dbus_cleanup_sockets_SOURCES=			\
 	dbus-cleanup-sockets.c
 
diff --git a/tools/dbus-run-session.1 b/tools/dbus-run-session.1
index 8b270ebe..32944d95 100644
--- a/tools/dbus-run-session.1
+++ b/tools/dbus-run-session.1
@@ -92,6 +92,14 @@ The session bus' address is made available to
 .I PROGRAM
 in the environment variable
 .BR DBUS_SESSION_BUS_ADDRESS .
+.P
+The variables
+.BR DBUS_SESSION_BUS_PID ,
+.BR DBUS_SESSION_BUS_WINDOWID ,
+.BR DBUS_STARTER_BUS_TYPE
+and
+.BR DBUS_STARTER_ADDRESS
+are removed from the environment, if present.
 .SH BUGS
 Please send bug reports to the D\-Bus mailing list or bug tracker,
 see http://www.freedesktop.org/software/dbus/
diff --git a/tools/dbus-run-session.c b/tools/dbus-run-session.c
index 4f0b32b5..f357aac5 100644
--- a/tools/dbus-run-session.c
+++ b/tools/dbus-run-session.c
@@ -35,6 +35,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 
+#include "dbus/dbus-misc.h"
+
 #define MAX_ADDR_LEN 512
 #define PIPE_READ_END  0
 #define PIPE_WRITE_END 1
@@ -99,22 +101,6 @@ oom (void)
   exit (1);
 }
 
-static void *
-xmalloc (size_t bytes)
-{
-  void *ret;
-
-  if (bytes == 0)
-    bytes = 1;
-
-  ret = malloc (bytes);
-
-  if (ret == NULL)
-    oom ();
-
-  return ret;
-}
-
 typedef enum
 {
   READ_STATUS_OK,    /**< Read succeeded */
@@ -227,7 +213,6 @@ main (int argc, char **argv)
   int requires_arg = 0;
   pid_t bus_pid;
   pid_t app_pid;
-  char *envvar;
 
   while (i < argc)
     {
@@ -396,11 +381,12 @@ main (int argc, char **argv)
 
   close (bus_address_pipe[PIPE_READ_END]);
 
-  envvar = xmalloc (strlen ("DBUS_SESSION_BUS_ADDRESS=") +
-                    strlen (bus_address) + 1);
-  strcpy (envvar, "DBUS_SESSION_BUS_ADDRESS=");
-  strcat (envvar, bus_address);
-  putenv (envvar);
+  if (!dbus_setenv ("DBUS_SESSION_BUS_ADDRESS", bus_address) ||
+      !dbus_setenv ("DBUS_SESSION_BUS_PID", NULL) ||
+      !dbus_setenv ("DBUS_SESSION_BUS_WINDOWID", NULL) ||
+      !dbus_setenv ("DBUS_STARTER_ADDRESS", NULL) ||
+      !dbus_setenv ("DBUS_STARTER_BUS_TYPE", NULL))
+    oom ();
 
   app_pid = fork ();
 
-- 
2.16.2


From 4cc72cfe2f6dd4ced0ae3fcb933ac384138a42ad Mon Sep 17 00:00:00 2001
From: David King <dking@redhat.com>
Date: Tue, 17 Jan 2017 20:41:17 +0000
Subject: [PATCH 3/4] dbus-run-session: assert impossible values of local enums
 are not reached

Based on part of a patch from Thomas Zimmermann. Adapted from commit
40560fa0c7ec921c8144296c72a80d20f403b8bf.
---
 tools/dbus-run-session.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/tools/dbus-run-session.c b/tools/dbus-run-session.c
index f357aac5..a92e601a 100644
--- a/tools/dbus-run-session.c
+++ b/tools/dbus-run-session.c
@@ -36,6 +36,7 @@
 #include <sys/wait.h>
 
 #include "dbus/dbus-misc.h"
+#include "dbus/dbus-internals.h"
 
 #define MAX_ADDR_LEN 512
 #define PIPE_READ_END  0
@@ -377,6 +378,9 @@ main (int argc, char **argv)
                me, strerror (errno));
       return 127;
       break;
+
+    default:
+      _dbus_assert_not_reached ("invalid read result");
     }
 
   close (bus_address_pipe[PIPE_READ_END]);
-- 
2.16.2


From 7b9bf51609570e3c4594fdcbe4fa03b2028c57c3 Mon Sep 17 00:00:00 2001
From: David King <dking@redhat.com>
Date: Tue, 14 Nov 2017 15:30:03 +0000
Subject: [PATCH 4/4] dbus-run-session: Flush stdout and stderr streams before
 forking

stdout and stderr are close-on-exec and buffered, so we can't rely on
their buffers being empty. If we continue to execute application code
after forking (as opposed to immediately exec()ing), then the child
process might later flush the libc stdio buffers, resulting in
output that is printed by the parent also being printed by the child.

In particular, test-bus.log sometimes grows extremely large for
this reason, because this test repeatedly attempts to carry out
legacy activation.

Adapted from commit 75a5cf655393649c664e73f16fb1215e677fd705.
---
 tools/dbus-run-session.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/tools/dbus-run-session.c b/tools/dbus-run-session.c
index a92e601a..a5466ea1 100644
--- a/tools/dbus-run-session.c
+++ b/tools/dbus-run-session.c
@@ -345,6 +345,11 @@ main (int argc, char **argv)
       return 127;
     }
 
+  /* Make sure our output buffers aren't redundantly printed by both the
+   * parent and the child */
+  fflush (stdout);
+  fflush (stderr);
+
   bus_pid = fork ();
 
   if (bus_pid < 0)
@@ -392,6 +397,9 @@ main (int argc, char **argv)
       !dbus_setenv ("DBUS_STARTER_BUS_TYPE", NULL))
     oom ();
 
+  fflush (stdout);
+  fflush (stderr);
+
   app_pid = fork ();
 
   if (app_pid < 0)
-- 
2.16.2

